import unittest
from coffea.util import load
import yaml
import sys
import os
sys.path.insert(0, os.getcwd())
from coffea4bees.plots.plots import load_config_4b
from src.plotting.plots import makePlot, load_hists, read_axes_and_cuts
from src.plotting.helpers_make_plot_dict import get_values_variances_centers_from_dict
import src.plotting.helpers as plot_helpers
import sys
import src.plotting.iPlot_config as cfg
import numpy as np
from src.tests.parser import wrapper
from unittest.mock import MagicMock
import matplotlib.pyplot as plt

#
# python3 coffea4bees/plots/tests/plot_test.py   --inputFile coffea4bees/analysis/hists/test.coffea --knownCounts src/tests/plotCounts.yml
#

class PlotTestCase(unittest.TestCase):

    @classmethod
    def setUpClass(self):

        #self.plotsAllDict = yaml.safe_load(open(, 'r'))
        metadata = "coffea4bees/plots/metadata/plotsAll.yml"
        #inputFile = "analysis/hists/test.coffea"
        inputFile = wrapper.args["inputFile"]

        cfg.plotConfig = load_config_4b(metadata)
        cfg.hists = load_hists([inputFile])
        cfg.axisLabels, cfg.cutList = read_axes_and_cuts(cfg.hists, cfg.plotConfig)

        #  Make these numbers with:
        #  >  python     src/tests/dumpPlotCounts.py --input [inputFileName] -o [outputFielName]
        #       (python src/tests/dumpPlotCounts.py --input coffea4bees/analysis/hists/test.coffea --output src/tests/testPlotCounts.yml)
        #
        knownCountFile = wrapper.args["knownCounts"]
        self.knownCounts = yaml.safe_load(open(knownCountFile, 'r'))


    def test_get_value_nested_dict(self):

        testDict = {"dA0" : {"dA1" : {"dA2": {"ka0" : "va0", "ka1" : "va1"} }, "ka2" : "va2"},
                    "dB0" : {"kb0" : "vb0"},
                    "kb1" : "vb1"}

        self.assertEqual(plot_helpers.get_value_nested_dict(testDict, "ka0"), "va0")
        self.assertEqual(plot_helpers.get_value_nested_dict(testDict, "ka1"), "va1")
        self.assertEqual(plot_helpers.get_value_nested_dict(testDict, "ka2"), "va2")
        self.assertEqual(plot_helpers.get_value_nested_dict(testDict, "kb0"), "vb0")
        self.assertEqual(plot_helpers.get_value_nested_dict(testDict, "kb1"), "vb1")

        value = plot_helpers.get_value_nested_dict(cfg.plotConfig, "fillcolor")
        self.assertEqual(value, "k")

    # Generated by chatGPT4
    def test_get_cut_dict(self):
        cut = 'cut1'
        cutList = ['cut1', 'cut2', 'cut3']

        # Call the function
        result = plot_helpers.get_cut_dict(cut, cutList)

        # Check the result is a dictionary
        self.assertIsInstance(result, dict, "The result should be a dictionary.")

        # Check the dictionary has all the cuts from cutList as keys
        self.assertTrue(all(c in result for c in cutList), "All cuts should be keys in the result dictionary.")

        # Check the specified cut is True
        self.assertTrue(result[cut], "The specified cut should be True.")

        # Check all other cuts are sum
        for c in cutList:
            if c != cut:
                self.assertTrue(result[c] == sum, f"{c} should be marked as sum.")



    def test_counts(self):

        default_args = {"doRatio":0, "rebin":4, "norm":0, "process":"Multijet"}

        for k, v  in self.knownCounts.items():
            print(f"testing...{k}")
            var = v["var"]
            cut = v["cut"]
            region = v["region"]
            counts = v["counts"]

            fig, axes = makePlot(cfg, var=var, cut=cut, axis_opts={"region":region},
                                 outputFolder=cfg.outputFolder, **default_args)

            ax = axes[0]
            for i in range(len(ax.lines)):

                if hasattr(ax.lines[i], "get_label") and ax.lines[i].get_label() == '_nolegend_':
                    y_plot = ax.lines[i].get_ydata()
                    break

            np.testing.assert_allclose(y_plot, counts,
                                       rtol=1e-10, atol=0)
            plt.close()

    def test_get_values_variances_centers_from_dict_hists_type(self):

        # Mocking histogram config
        hist_config = {"name": "hist1",
                       "values": [1, 2, 3],
                       "variances": [4, 5, 6],
                       "centers": [0.5, 1.5, 2.5],
                       }

        # Setting up inputs
        input_dict = {"type": "hists", "key": "hist1"}
        stack_dict = {}

        # Expected values
        expected_values = np.array([1, 2, 3])
        expected_centers = np.array([0.5, 1.5, 2.5])
        expected_variances = np.array([4, 5, 6])

        # Test
        plot_data = {}
        plot_data["hists"] = {"hist1":hist_config}
        plot_data["stack"] = stack_dict

        values, variances, centers = get_values_variances_centers_from_dict(input_dict, plot_data)
        np.testing.assert_array_equal(values,    expected_values)
        np.testing.assert_array_equal(variances, expected_variances)
        np.testing.assert_array_equal(centers,   expected_centers)


    def test_stack_type(self):
        # Mocking histogram objects
        hist_mock = MagicMock()
        hist_mock.values.return_value = np.array([1, 2, 3])
        hist_mock.axes[0].centers = np.array([0.5, 1.5, 2.5])
        stack_dummy = {"values": [1, 2, 3],
                       "variances": [4, 5, 6],
                       "centers": [0.5, 1.5, 2.5]}

        stack_dict = {"stack1": stack_dummy, "stack2": stack_dummy}

        # Setting up inputs
        input_dict = {"type": "stack"}

        # Test
        plot_data = {}
        plot_data["hists"] = {}
        plot_data["stack"] = stack_dict


        # Expected values (sum of two histograms)
        expected_values    = np.array([2, 4, 6])
        expected_variances = np.array([8, 10, 12])
        expected_centers   = np.array([0.5, 1.5, 2.5])

        # Test
        values, variances, centers = get_values_variances_centers_from_dict(input_dict, plot_data)
        np.testing.assert_array_equal(values,    expected_values)
        np.testing.assert_array_equal(variances, expected_variances)
        np.testing.assert_array_equal(centers,   expected_centers)



if __name__ == '__main__':
    wrapper.parse_args()
    unittest.main(argv=sys.argv)
